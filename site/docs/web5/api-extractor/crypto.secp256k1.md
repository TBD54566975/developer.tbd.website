<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [@web5/crypto](./crypto.md) &gt; [Secp256k1](./crypto.secp256k1.md)

## Secp256k1 class

The `Secp256k1` class provides an interface for generating secp256k1 key pairs, computing public keys from private keys, generating shaerd secrets, and signing and verifying messages.

The class uses the '<!-- -->@<!-- -->noble/secp256k1' package for the cryptographic operations, and the '<!-- -->@<!-- -->noble/hashes/sha256' package for generating the hash digests needed for the signing and verification operations.

The methods of this class are all asynchronous and return Promises. They all use the Uint8Array type for keys, signatures, and data, providing a consistent interface for working with binary data.

Example usage:

```ts
const keyPair = await Secp256k1.generateKeyPair();
const message = new TextEncoder().encode('Hello, world!');
const signature = await Secp256k1.sign({
  algorithm: { hash: 'SHA-256' },
  key: keyPair.privateKey,
  data: message
});
const isValid = await Secp256k1.verify({
  algorithm: { hash: 'SHA-256' },
  key: keyPair.publicKey,
  signature,
  data: message
});
console.log(isValid); // true
```

**Signature:**

```typescript
export declare class Secp256k1 
```

## Methods

|  Method | Modifiers | Description |
|  --- | --- | --- |
|  [convertPublicKey(options)](./crypto.secp256k1.convertpublickey.md) | <code>static</code> | <p>Converts a public key between its compressed and uncompressed forms.</p><p>Given a public key, this method can either compress or decompress it depending on the provided <code>compressedPublicKey</code> option. The conversion process involves decoding the Weierstrass points from the key bytes and then returning the key in the desired format.</p><p>This is useful in scenarios where space is a consideration or when interfacing with systems that expect a specific public key format.</p> |
|  [generateKeyPair(options)](./crypto.secp256k1.generatekeypair.md) | <code>static</code> | Generates a secp256k1 key pair. |
|  [getCurvePoints(options)](./crypto.secp256k1.getcurvepoints.md) | <code>static</code> | <p>Returns the elliptic curve points (x and y coordinates) for a given secp256k1 key.</p><p>In the case of a private key, the public key is first computed from the private key, then the x and y coordinates of the public key point on the elliptic curve are returned.</p><p>In the case of a public key, the x and y coordinates of the key point on the elliptic curve are returned directly.</p><p>The returned coordinates can be used to perform various operations on the elliptic curve, such as addition and multiplication of points, which can be used in various cryptographic schemes and protocols.</p> |
|  [getPublicKey(options)](./crypto.secp256k1.getpublickey.md) | <code>static</code> | Computes the public key from a given private key. If compressedPublicKey=true then the output is a 33-byte public key. If compressedPublicKey=false then the output is a 65-byte public key. |
|  [sharedSecret(options)](./crypto.secp256k1.sharedsecret.md) | <code>static</code> | <p>Generates a RFC6090 ECDH shared secret given the private key of one party and the public key another party.</p><p>Note: When performing Elliptic Curve Diffie-Hellman (ECDH) key agreement, the resulting shared secret is a point on the elliptic curve, which consists of an x-coordinate and a y-coordinate. With a 256-bit curve like secp256k1, each of these coordinates is 32 bytes (256 bits) long. However, in the ECDH process, it's standard practice to use only the x-coordinate of the shared secret point as the resulting shared key. This is because the y-coordinate does not add to the entropy of the key, and both parties can independently compute the x-coordinate, so using just the x-coordinate simplifies matters.</p> |
|  [sign(options)](./crypto.secp256k1.sign.md) | <code>static</code> | Generates a RFC6979 ECDSA signature of given data with a given private key and hash algorithm. |
|  [validatePrivateKey(options)](./crypto.secp256k1.validateprivatekey.md) | <code>static</code> | <p>Validates a given private key to ensure that it's a valid 32-byte number that is less than the secp256k1 curve's order.</p><p>This method checks the byte length of the key and its numerical validity according to the secp256k1 curve's parameters. It doesn't verify whether the key corresponds to a known or authorized entity or whether it has been compromised.</p> |
|  [validatePublicKey(options)](./crypto.secp256k1.validatepublickey.md) | <code>static</code> | <p>Validates a given public key to ensure that it corresponds to a valid point on the secp256k1 elliptic curve.</p><p>This method decodes the Weierstrass points from the key bytes and asserts their validity on the curve. If the points are not valid, the method returns false. If the points are valid, the method returns true.</p><p>Note: This method does not check whether the key corresponds to a known or authorized entity, or whether it has been compromised. It only checks the mathematical validity of the key.</p> |
|  [verify(options)](./crypto.secp256k1.verify.md) | <code>static</code> | Verifies a RFC6979 ECDSA signature of given data with a given public key and hash algorithm. |

