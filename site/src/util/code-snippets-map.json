{
  "getProtocolDefinition": "const { protocol } = await web5.dwn.protocols.configure({\n    message: {\n      definition: protocolDefinition\n    }\n  });\n\n  //highlight-start\n  const definition = protocol.definition;\n  //highlight-end",
  "configureProtocolAndSend": "const { protocol } = await web5.dwn.protocols.configure({\n    message: {\n      definition: protocolDefinition\n    }\n  });\n\n \n  //highlight-start\n  const {status} = await protocol.send(myDid);\n  //highlight-end",
  "queryProtocol": "const { protocols } = await web5.dwn.protocols.query({\n    message: {\n      filter: {\n        protocol: 'http://social-media.xyz'\n      }\n    }\n  });\n\n  //highlight-start\n  const protocolConfig = protocols[0].toJSON();\n  //highlight-end",
  "configureProtocolWithDefinition": "const { protocol, status } = await web5.dwn.protocols.configure({\n    message: {\n      definition: {\n        \"protocol\": \"https://photos.org/protocol\",\n        \"published\": false,\n        \"types\": {\n          \"album\": {\n            \"schema\": \"https://photos.org/protocol/album\",\n            \"dataFormats\": [\"application/json\"]\n          },\n          \"photo\": {\n            \"schema\": \"https://photos.org/protocols/photo\",\n            \"dataFormats\": [\"application/json\"]\n          },\n          \"binaryImage\": {\n            \"dataFormats\": [\"image/png\", \"jpeg\", \"gif\"]\n          },\n          \"comment\": {\n            \"schema\": \"https://photos.org/protocols/comment\",\n            \"dataFormats\": [\"application/json\"]\n          }\n        },\n        \"structure\": {\n          \"album\": {\n            \"$actions\": [\n              { \"who\": \"author\", \"of\": \"album\", \"can\": \"write\" }\n            ]\n          },\n          \"photo\": {\n            \"$actions\": [\n              { \"who\": \"recipient\", \"of\": \"photo\", \"can\": \"read\" }\n            ],\n            \"binaryImage\": {\n              \"$actions\": [\n                { \"who\": \"author\", \"of\": \"photo\", \"can\": \"write\" }\n              ]\n            },\n            \"comment\": {\n              \"$actions\": [\n                { \"who\": \"anyone\", \"can\": \"write\" },\n                { \"who\": \"anyone\", \"can\": \"read\" },\n                { \"who\": \"author\", \"of\": \"comment\", \"can\": \"delete\" },\n                { \"who\": \"recipient\", \"of\": \"comment\", \"can\": \"delete\" },\n                { \"who\": \"author\", \"of\": \"comment\", \"can\": \"update\" }\n              ]\n            }\n          }\n        }\n      }\n    },\n  });",
  "queryMusicProtocol": "const { protocols, status } = await web5.dwn.protocols.query({\n    message: {\n      filter: {\n        protocol: 'https://music.org/protocol',\n      },\n    },\n  });\n\n  // logs an array of protocol configurations installed on the user's DWN\n  console.log(protocols);",
  "queryProtocolDescending": "// Sorting protocols by dateCreated in descending order\n\n  const { protocols, status } = await web5.dwn.protocols.query({\n    message: {\n      filter: {\n        protocol: 'http://social-media.xyz',\n      },\n      //highlight-start\n      dateSort: 'createdDescending',\n      //highlight-end\n    },\n  });",
  "queryProtocolsFromDid": "//Query protocol on someone else's DWN\n  \n  const { protocols } = await web5.dwn.protocols.query({\n    //highlight-start\n    from: bobDid,\n    //highlight-end\n    message: {\n      filter: {\n        protocol: 'https://music.org/protocol',\n      },\n    },\n  });\n\n  // logs an array of protocol configurations installed on Bob's DWN\n  console.log(protocols);",
  "createRecordWithHighlight": "const { record } = await web5.dwn.records.create({\n    data: 'Hello World!',\n    message: {\n      dataFormat: 'text/plain',\n    },\n  });\n\n  //highlight-start\n  const { status } = await record.send(myDid);\n  //highlight-end",
  "createRecord": "const { record } = await web5.dwn.records.create({\n    data: 'Hello World!',\n    message: {\n      dataFormat: 'text/plain',\n    },\n  });\n\n  const { status } = await record.send(myDid);",
  "readRecord": "const recordText = await textRecord.data.text();",
  "deleteRecord": "const response = await web5.dwn.records.delete({\n    from: did,\n    message: { \n      recordId: recordId\n    },\n  });",
  "updateRecord": "const response = await record.update({ data: \"Hello', I'm updated\" });",
  "createRecordsWithPlaylist": "const { record } = await web5.dwn.records.create({\n    data: playlistJson,\n    message: {\n      recipient: 'did:example:alice',\n      schema: 'https://schema.org/Playlist',\n      dataFormat: 'application/json',\n    },\n  });",
  "createRecordWithoutStore": "// this creates a record, but does not store it in the user's local DWN\n  const { record } = await web5.dwn.records.create({\n    //highlight-start\n    store: false,\n    //highlight-end\n    data: 'Hello again, World!',\n    message: {\n      recipient: 'did:example:alice',\n      dataFormat: 'text/plain',\n    },\n  });",
  "createRecordAndSend": "// this creates a record and stores it in the user's local DWN\n  const { record } = await web5.dwn.records.create({\n    data: 'Hello World!',\n    message: {\n      dataFormat: 'text/plain',\n    },\n  });\n\n  /*\n  send the record to the user's remote DWNs. Only needed\n  if it's a record that cannot wait for sync to occur.\n  */\n  const { status: myDidStatus } = await record.send(myDid);\n\n  // send the newly generated record to Bob's DWNs\n  const { status: bobStatus } = await record.send(bobDid);",
  "queryPlaylistFromDid": "const response = await web5.dwn.records.query({\n    from: myDid,\n    message: {\n      filter: {\n        schema: 'https://schema.org/Playlist',\n        dataFormat: 'application/json',\n      },\n    },\n  });\n\n  // response.records.forEach((record) => {\n  //   console.log(record.id);\n  // });",
  "sortQueriedRecordsByDate": "// Sorting records by dateCreated in ascending order\n  const response = await web5.dwn.records.query({\n    message: {\n      filter: {\n        dataFormat: 'text/plain',\n      },\n      //highlight-start\n      dateSort: 'createdAscending',\n      //highlight-end\n    },\n  });",
  "readRecordFromId": "// Reads the indicated record from the user's DWNs\n  let { record } = await web5.dwn.records.read({\n    message: {\n      filter: {\n        recordId: recordId,\n      },\n    },\n  });\n\n  // assuming the record has a text payload\n  const text = await record.data.text();",
  "readRecordByIdFromDid": "// Reads the indicated record from Bob's DWNs\n  const { record } = await web5.dwn.records.read({\n    //highlight-start\n    from: bobDid,\n    //highlight-end\n    message: {\n      filter: {\n        recordId: recordId,\n      },\n    },\n  });\n\n  // assuming the record is a json payload\n  const data = await record.data.json();",
  "deleteRecordFromDid": "const response = await web5.dwn.records.delete({\n    //highlight-next-line\n    from: did,\n    message: {\n      recordId: record.id,\n    },\n  });",
  "connectWithDWNEndpoint": "const { web5, did } = await Web5.connect({\n    techPreview: {\n      dwnEndpoints: ['https://dwn.your-domain.org/'],\n    },\n  });",
  "connectWithAgentAndConnectedDid": "const { web5, did } = await Web5.connect({\n    agent: identityAgent,\n    connectedDid: existingDid,\n  });",
  "connectWithSyncConfig": "const { web5, did } = await Web5.connect({\n    sync: '5s',\n  });",
  "createRecordWithTodoItem": "const myRecord = await web5.dwn.records.create(myDid.id, {\n    data: 'todoItem',\n    message: {\n      dataFormat: 'text/plain',\n    },\n  });",
  "createAliceDid": "const { web5, did: aliceDid } = await Web5.connect();\n\n  // Create the record\n  const { record } = await web5.dwn.records.create({\n    data: 'Hello Web5',\n    message: {\n      dataFormat: 'text/plain',\n    },\n  });\n\n  // Read the record\n  const readResult = await record.data.text();",
  "createDidAutomatically": "const { web5, did: userDid } = await Web5.connect();",
  "createDidDht": "//Creates a DID using the DHT method and publishes the DID Document to the DHT\n  const didDht = await DidDhtMethod.create({ publish: true });\n\n  //DID and its associated data which can be exported and used in different contexts/apps\n  const portableDID = JSON.stringify(didDht);\n\n  //DID string\n  const did = didDht.did;\n\n  //DID Document\n  const didDocument = JSON.stringify(didDht.document);\n\n  //Cryptographic keys associated with DID\n  const keys = JSON.stringify(didDht.keySet);\n\n  //Primary form of a DID. more info: https://www.w3.org/TR/did-core/#dfn-canonicalid\n  const canonicalId = didDht.canonicalId;",
  "createDidKey": "//Creates a DID using the did:key method\n  const didKey = await DidKeyMethod.create();\n\n  //DID and its associated data which can be exported and used in different contexts/apps\n  const portableDID = JSON.stringify(didKey);\n\n  //DID string\n  const did = didKey.did;\n\n  //DID Document\n  const didDocument = JSON.stringify(didKey.document);\n\n  //Cryptographic keys associated with DID\n  const keys = JSON.stringify(didKey.keySet);\n\n  //Primary form of a DID. more info: https://www.w3.org/TR/did-core/#dfn-canonicalid\n  const canonicalId = didKey.canonicalId;",
  "deleteFromLocalDWN": "const deleteResult = await web5.dwn.records.delete({\n    message: {\n      recordId: recordId\n    },\n  });",
  "createPublishedRecord": "const {record} = await web5.dwn.records.create({\n    data: \"a published record\",\n    message: {\n      dataFormat: \"text/plain\",\n      //highlight-start\n      published: true\n      //highlight-end\n    }\n  });",
  "createRecordWithDatePublished": "// Create a new Date instance for tomorrow\nconst today = new Date();\nconst tomorrow = new Date(today);\ntomorrow.setDate(today.getDate() + 1);\n\n// Format the date and time in YYYY-MM-DDThh:mm:ss.ssssssZ format\nconst formattedDate = tomorrow.toISOString().replace(/\\.\\d{3}Z$/, '.000000Z');\n\n// Create a record today to be published tomorrow\nconst { record } = await web5.dwn.records.create({\n  data: \"This record will be created now and published tomorrow\",\n  message: {\n    dataFormat: \"text/plain\",\n    //highlight-start\n    published: true,\n    datePublished: formattedDate\n    //highlight-end\n  },\n});",
  "queryProtocolsForMusic": "const { protocols } = await web5.dwn.protocols.query({\n    message: {\n      filter: {\n        protocol: 'https://music.org/protocol',\n      },\n    },\n  });",
  "queryProtocolsWithFilterDescending": "const { protocols } = await web5.dwn.protocols.query({\n    message: {\n      filter: {\n        protocol: 'http://social-media.xyz',\n      },\n      //highlight-next-line\n      dateSort: 'createdDescending'\n    },\n  });",
  "queryRecordsWithFilterAscending": "const response = await web5.dwn.records.query({\n    message: {\n      filter: {\n        dataFormat: 'text/plain',\n      },\n      //highlight-next-line\n      dateSort: 'publishedAscending',\n    },\n  });",
  "queryRecordsFromDid": "const { records } = await web5.dwn.records.query({\n    //highlight-next-line\n    from: did,\n    message: {\n      filter: {\n        schema: 'https://schema.org/Playlist',\n        dataFormat: 'application/json',\n      },\n    },\n  });",
  "queryRecordWithParentId": "const response = await web5.dwn.records.query({\n    message: {\n      filter: {\n        parentId: 'bafyreianzpmhbgcgam5mys722vnsiuwn7y4ek6kjeyjptttquasw4hge2m',\n      },\n    },\n  });",
  "playlistProtocolDefinition": "const playlistProtocolDefinition =  {\n    protocol: \"https://playlist.org/protocol\",\n    published: true,\n    types: {\n      playlist: {\n        schema: \"https://schema.org/MusicPlaylist\",\n        dataFormats: [\"application/json\"],\n      },\n      audio: {\n        schema: \"https://schema.org/AudioObject\",\n        dataFormats: [\"audio/mp3\"],\n      },\n      video: {\n        schema: \"https://schema.org/VideoObject\",\n        dataFormats: [\"video/mp4\"],\n      },\n    },\n    structure: {\n      playlist: {\n        $actions: [\n          { who: \"anyone\", can: \"write\" },\n          { who: \"author\", of: \"playlist\", can: \"read\" },\n          { who: \"recipient\", of: \"playlist\", can: \"read\" },\n        ],\n        audio: {\n          $actions: [\n            { who: \"anyone\", can: \"write\" },\n            { who: \"author\", of: \"audio\", can: \"read\" },\n            { who: \"recipient\", of: \"audio\", can: \"read\" },\n          ],\n        },\n        video: {\n          $actions: [\n            { who: \"anyone\", can: \"write\" },\n            { who: \"author\", of: \"video\", can: \"read\" },\n            { who: \"recipient\", of: \"video\", can: \"read\" },\n          ]\n        },\n      },\n    }\n  };",
  "queryFromDwnByProtocolPath": "const { records } = await web5.dwn.records.query({\n    message: {\n      filter: {\n        //highlight-start\n        protocol: 'https://playlist.org/protocol',\n        protocolPath: 'playlist/video'\n        //highlight-end\n      },\n    },\n  });",
  "readFromDwn": "const response = await web5.dwn.records.query({\n    message: {\n      filter: {\n        dataFormat: 'text/plain',\n      },\n    },\n  });",
  "createLocalRecord": "const { record } = await web5.dwn.records.create({\n    data: \"this record will be written to the local DWN\",\n    message: {\n        dataFormat: 'text/plain'\n    }\n});",
  "createLocalProtocol": "const response = await web5.dwn.protocols.configure({\n    message: {\n        definition: protocolDefinition\n    }\n});",
  "sendLocalRecordToTarget": "const { record } = await web5.dwn.records.create({\n    data: \"this record will be written to the target's local DWN\",\n    message: {\n        target: targetDid,\n        dataFormat: 'text/plain'\n    }\n});",
  "sendRecordToRemoteDWNs": "const { record } = await web5.dwn.records.create({\n    data: \"this record will be written to the local DWN\",\n    message: {\n        dataFormat: 'text/plain'\n    }\n});\n\n//immediately send record to user's remote DWNs\nconst {status} = await record.send(userDid);",
  "sendProtocolToRemoteDWNs": "const { protocol } = await web5.dwn.protocols.configure({\n    message: {\n        definition: protocolDefinition\n    }\n});\n\n//immediately send protocol to user's remote DWNs\nconst {status} = await protocol.send(userDid);",
  "sendRecordToDWNOfRecipient": "const { record } = await web5.dwn.records.create({\n    data: \"this record will be created but not saved to DWN\",\n    store: false, //remove this line if you want to keep a copy of the record in the sender's DWN\n    message: {\n        dataFormat: 'text/plain'\n    },\n});\n\n//send record to recipient's DWN\nconst {status} = await record.send(recipientDid);",
  "updateDwnRecord": "// Get the record\nconst { record } = await web5.dwn.records.read({\n  message: {\n    filter: {\n      recordId: createdRecord.id\n    }\n  }\n});\n\n// Update the record\n// highlight-next-line\nconst {status} = await record.update({ data: \"Hello, I'm updated!\" });",
  "createIdentityAgent": "const agent = await IdentityAgent.create();",
  "authenticateIdentityAgent": "await agent.start({ passphrase: 'default-passphrase' });",
  "getDwnEndpoints": "// selects DWN endpoints that are provided by default during the Web5 tech preview period\nconst serviceEndpointNodes = await getTechPreviewDwnEndpoints();\n\n// generates key pairs used for authorization and encryption when interfacing with DWNs\nconst didOptions = await DidIonMethod.generateDwnOptions({ serviceEndpointNodes });",
  "createSocialMediaAndCareerIdentity": "const socialMediaIdentity = await agent.identityManager.create({\n        name: 'SocialMedia',\n        didMethod: 'ion',\n        didOptions,\n        kms: 'local'\n    });\n\n    const careerIdentity = await agent.identityManager.create({\n        name: 'Career',\n        didMethod: 'ion',\n        didOptions,\n        kms: 'local'\n    });",
  "connectIdentityToWeb5": "const { web5 } = await Web5.connect({\n        connectedDid: socialMediaIdentity.did,\n        agent,\n    });",
  "connectToWeb5": "const { web5 } = await Web5.connect({\n        connectedDid: socialIdentity.did,\n        agent,\n    });",
  "createTextRecord": "const { record } = await web5.dwn.records.create({\n    data: 'Hello, Web5!',\n    message: {\n      dataFormat: 'text/plain',\n    },\n  });",
  "createJsonRecord": "// Create a JSON record\nconst { record } = await web5.dwn.records.create({\n    data: {\n        content: \"Hello Web5\",\n        description: \"Keep Building!\"\n    },\n    message: {\n        dataFormat: 'application/json'\n    }\n});",
  "uploadImage": "// Create a blob record\n    async function upload(event) {\n        const blob = new Blob(event.currentTarget.files, { type: \"image/png\" });\n        const { record } = await web5.dwn.records.create({\n            data: blob,\n            message: {\n                dataFormat: \"image/png\"\n            }\n        });\n        \n    }",
  "uploadFile": "// Create a file record\n    async function upload(event) {\n        const file = event.currentTarget.files[0];\n        const { status: fileStatus, record } = await web5.dwn.records.create({\n            data: file,\n            message: {\n                schema: \"https://schema.org/path/to/schema\",\n                dataFormat: \"application/octet-stream\"\n            }\n        });\n        \n    }",
  "createMixedRecord": "// Create a mixed record\n    async function createMessage(username, messageText, imageFile) {\n        let base64Image = null;\n        \n        if (imageFile) {\n            const binaryImage = await imageFile.arrayBuffer();\n            base64Image = btoa(\n                new Uint8Array(binaryImage).reduce(\n                    (data, byte) => data + String.fromCharCode(byte),\n                    \"\"\n                )\n            );\n        }\n\n        const messageData = {\n            username,\n            message: messageText,\n            image: base64Image\n        };\n\n        const { record } = await web5.dwn.records.create({\n            data: messageData,\n            message: {\n                schema: \"http://schema-registry.org/message\",\n                dataFormat: \"application/json\"\n            },\n        });\n        \n    }",
  "assignVcJwt": "const signedVcJwt = \"eyJ0eXAiOiJKV1QiLCJhbGciOiJFZERTQSIsImtpZCI6ImRpZDpkaHQ6a2ZkdGJjbTl6Z29jZjVtYXRmOWZ4dG5uZmZoaHp4YzdtZ2J3cjRrM3gzcXppYXVjcHA0eSMwIn0.eyJ2YyI6eyJAY29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvMjAxOC9jcmVkZW50aWFscy92MSJdLCJ0eXBlIjpbIlZlcmlmaWFibGVDcmVkZW50aWFsIiwiRW1wbG95bWVudENyZWRlbnRpYWwiXSwiaWQiOiJ1cm46dXVpZDo4ZmQ1MjAzMC0xY2FmLTQ5NzgtYTM1ZC1kNDE3ZWI4ZTAwYjIiLCJpc3N1ZXIiOiJkaWQ6ZGh0OmtmZHRiY205emdvY2Y1bWF0ZjlmeHRubmZmaGh6eGM3bWdid3I0azN4M3F6aWF1Y3BwNHkiLCJpc3N1YW5jZURhdGUiOiIyMDIzLTEyLTIxVDE3OjAyOjAxWiIsImNyZWRlbnRpYWxTdWJqZWN0Ijp7ImlkIjoiZGlkOmRodDp5MzltNDhvem9ldGU3ejZmemFhbmdjb3M4N2ZodWgxZHppN2Y3andiamZ0N290c2toOXRvIiwicG9zaXRpb24iOiJTb2Z0d2FyZSBEZXZlbG9wZXIiLCJzdGFydERhdGUiOiIyMDIxLTA0LTAxVDEyOjM0OjU2WiIsImVtcGxveW1lbnRTdGF0dXMiOiJDb250cmFjdG9yIn0sImV4cGlyYXRpb25EYXRlIjoiMjAyMi0wOS0zMFQxMjozNDo1NloifSwiaXNzIjoiZGlkOmRodDprZmR0YmNtOXpnb2NmNW1hdGY5Znh0bm5mZmhoenhjN21nYndyNGszeDNxemlhdWNwcDR5Iiwic3ViIjoiZGlkOmRodDp5MzltNDhvem9ldGU3ejZmemFhbmdjb3M4N2ZodWgxZHppN2Y3andiamZ0N290c2toOXRvIn0.ntcgPOdXOatULWo-q6gkuhKmi5X3bzCONQY38t_rsC1hVhvvdAtmiz-ccoLIYUkjECRHIxO_UZbOKgn0EETBCA\";",
  "parseSignedVcJwt": "const vc = VerifiableCredential.parseJwt({ vcJwt: signedVcJwt });",
  "validatePresentationDefinition": "const validation = PresentationExchange.validateDefinition({ \n    presentationDefinition: pd \n});",
  "pex_getLoanAppPresentationDefinition": "const presentationDefinition = {\n    id: 'presDefIdloanAppVerification123',\n    name: 'Loan Application Employment Verification',\n    purpose: 'To verify applicant’s employment, date of birth, and name',\n    input_descriptors: [\n      // Employment Verification\n      {\n        id: 'employmentVerification',\n        purpose: 'Confirm current employment status',\n        constraints: {\n          fields: [\n            {\n              path: ['$.credentialSubject.employmentStatus'],\n              filter: {\n                type: 'string',\n                pattern: 'employed',\n              },\n            },\n          ],\n        },\n      },\n      // Date of Birth Verification\n      {\n        id: 'dobVerification',\n        purpose: 'Confirm the applicant’s date of birth',\n        constraints: {\n          fields: [\n            {\n              path: ['$.credentialSubject.dateOfBirth'],\n              filter: {\n                type: 'string',\n                format: 'date',\n              },\n            },\n          ],\n        },\n      },\n      // Name Verification\n      {\n        id: 'nameVerification',\n        purpose: 'Confirm the applicant’s legal name',\n        constraints: {\n          fields: [\n            {\n              path: ['$.credentialSubject.name'],\n              filter: {\n                type: 'string'\n              }\n            }\n          ]\n        }\n      }\n    ]\n  };",
  "pex_selectCredentials": "const selectedCredentials = PresentationExchange.selectCredentials({\n    vcJwts: allCredentials,\n    presentationDefinition: presentationDefinition\n  });",
  "pex_checkPresentationDefinitionSatisfaction": "try {\n    PresentationExchange.satisfiesPresentationDefinition({ \n        vcJwts: selectedCredentials, \n        presentationDefinition: presentationDefinition\n    });\n  } catch (err) {\n    //Handle errors here\n    \n  }",
  "pex_createPresentationFromCredentials": "const presentationResult = PresentationExchange.createPresentationFromCredentials({\n      vcJwts: selectedCredentials,\n      presentationDefinition: presentationDefinition\n    });",
  "pex_submissionCheck": "const submissionCheck = PresentationExchange.validateSubmission({\n    presentationSubmission: presentationResult.presentationSubmission\n  });",
  "pex_getPresentationFromResult": "const presentation = presentationResult.presentation;",
  "test1VcJwt": "const signedVcJwt =\n    'eyJ0eXAiOiJKV1QiLCJhbGciOiJFZERTQSIsImtpZCI6ImRpZDpkaHQ6a2ZkdGJjbTl6Z29jZjVtYXRmOWZ4dG5uZmZoaHp4YzdtZ2J3cjRrM3gzcXppYXVjcHA0eSMwIn0.eyJ2YyI6eyJAY29udGV4dCI6WyJodHRwczovL3d3dy53My5vcmcvMjAxOC9jcmVkZW50aWFscy92MSJdLCJ0eXBlIjpbIlZlcmlmaWFibGVDcmVkZW50aWFsIiwiRW1wbG95bWVudENyZWRlbnRpYWwiXSwiaWQiOiJ1cm46dXVpZDo4ZmQ1MjAzMC0xY2FmLTQ5NzgtYTM1ZC1kNDE3ZWI4ZTAwYjIiLCJpc3N1ZXIiOiJkaWQ6ZGh0OmtmZHRiY205emdvY2Y1bWF0ZjlmeHRubmZmaGh6eGM3bWdid3I0azN4M3F6aWF1Y3BwNHkiLCJpc3N1YW5jZURhdGUiOiIyMDIzLTEyLTIxVDE3OjAyOjAxWiIsImNyZWRlbnRpYWxTdWJqZWN0Ijp7ImlkIjoiZGlkOmRodDp5MzltNDhvem9ldGU3ejZmemFhbmdjb3M4N2ZodWgxZHppN2Y3andiamZ0N290c2toOXRvIiwicG9zaXRpb24iOiJTb2Z0d2FyZSBEZXZlbG9wZXIiLCJzdGFydERhdGUiOiIyMDIxLTA0LTAxVDEyOjM0OjU2WiIsImVtcGxveW1lbnRTdGF0dXMiOiJDb250cmFjdG9yIn0sImV4cGlyYXRpb25EYXRlIjoiMjAyMi0wOS0zMFQxMjozNDo1NloifSwiaXNzIjoiZGlkOmRodDprZmR0YmNtOXpnb2NmNW1hdGY5Znh0bm5mZmhoenhjN21nYndyNGszeDNxemlhdWNwcDR5Iiwic3ViIjoiZGlkOmRodDp5MzltNDhvem9ldGU3ejZmemFhbmdjb3M4N2ZodWgxZHppN2Y3andiamZ0N290c2toOXRvIn0.ntcgPOdXOatULWo-q6gkuhKmi5X3bzCONQY38t_rsC1hVhvvdAtmiz-ccoLIYUkjECRHIxO_UZbOKgn0EETBCA';",
  "createEmploymentCredential": "const vc = await VerifiableCredential.create({\n    type: 'EmploymentCredential',\n    issuer: employer.did,\n    subject: employee.did,\n    expirationDate: '2023-09-30T12:34:56Z',\n    data: {\n        \"position\": \"Software Developer\",\n        \"startDate\": \"2023-04-01T12:34:56Z\",\n        \"employmentStatus\": \"Contractor\"\n    }\n});",
  "signCredential": "//sign with PortableDid\nconst vc_jwt_employment = await vc.sign({ did: employer });",
  "verifyCredentials": "//highlight-next-line\nconst vcJwtArray = presentationResult.presentation.verifiableCredential;\nconst verificationResults = [];\nlet errorsFound = false;\n\nfor (let vcJwt of vcJwtArray) {\n    try {\n        //highlight-next-line\n        const verificationResult = await VerifiableCredential.verify({ vcJwt: vcJwt });\n        \n        //no error thrown\n        verificationResults.push({\n            jwt: vcJwt,\n            result: verificationResult,\n            isValid: true,\n            error: null\n        });\n    } catch (error) {\n        errorsFound = true;\n        verificationResults.push({\n            jwt: vcJwt,\n            result: null,\n            isValid: false,\n            error: error.message\n        });\n    }\n}",
  "checkVerificationResults": "if(errorsFound) {\n    verificationResults.forEach(result => {\n        if (!result.isValid) {\n            console.log(`Error: ${result.error} for JWT ${result.jwt}`);\n        }\n    });\n}\nelse {\n    //no errors are found. continue processing\n}",
  "evaluatePresentation": "const evaluationResults = PresentationExchange.evaluatePresentation({\n    presentationDefinition: presentationDefinition, \n    presentation: presentationResult.presentation \n});",
  "didCreate": "const { web5, did: aliceDid } = await Web5.connect();",
  "readTextRecord": "const readResult = await record.data.text();",
  "updateTextRecord": "const updateResult = await record.update({\n    data: 'Hello, Web5! I am updated.',\n  });",
  "deleteTextRecord": "const deleteResult = await web5.dwn.records.delete({\n    message: {\n      recordId: record.id,\n    },\n  });"
}
